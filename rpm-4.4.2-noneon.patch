Allow build without the neon library. Resurrects old httpOpen
code from rpm-4.1.1.
Building without neon means no webdav file uploads, though.

Index: rpm-4.4.2/rpmio/rpmdav.c
===================================================================
--- rpm-4.4.2.orig/rpmio/rpmdav.c
+++ rpm-4.4.2/rpmio/rpmdav.c
@@ -9,6 +9,8 @@
 #include <pthread.h>
 #endif
 
+#ifdef WITH_NEON
+
 #include "ne_alloc.h"
 #include "ne_auth.h"
 #include "ne_basic.h"
@@ -27,6 +29,8 @@
 #include "ne_string.h"
 #include "ne_utils.h"
 
+#endif /* WITH_NEON */
+
 #include <rpmio_internal.h>
 
 #define _RPMDAV_INTERNAL
@@ -61,6 +65,8 @@ _free(/*@only@*/ /*@null@*/ /*@out@*/ co
     return NULL;
 }
 
+#ifdef WITH_NEON
+
 /* =============================================================== */
 static int davFree(urlinfo u)
 	/*@globals internalState @*/
@@ -1370,6 +1376,8 @@ fprintf(stderr, "*** davReadlink(%s) rc 
 }
 #endif	/* NOTYET */
 
+#endif /* WITH_NEON */
+
 /* =============================================================== */
 /*@unchecked@*/
 int avmagicdir = 0x3607113;
@@ -1494,6 +1502,8 @@ fprintf(stderr, "*** avOpendir(%s)\n", p
 }
 /*@=boundswrite@*/
 
+#ifdef WITH_NEON
+
 /* =============================================================== */
 /*@unchecked@*/
 int davmagicdir = 0x8440291;
@@ -1661,4 +1671,6 @@ fprintf(stderr, "*** davOpendir(%s)\n", 
     return (DIR *) avdir;
 /*@=kepttrans@*/
 }
+
+#endif /* WITH_NEON */
 /*@=modfilesys@*/
Index: rpm-4.4.2/rpmio/rpmio.c
===================================================================
--- rpm-4.4.2.orig/rpmio/rpmio.c
+++ rpm-4.4.2/rpmio/rpmio.c
@@ -375,7 +375,11 @@ static ssize_t fdRead(void * cookie, /*@
 /*@-boundswrite@*/
     /* HACK: flimsy wiring for davRead */
     if (fd->req != NULL) {
+#ifdef WITH_NEON
 	rc = davRead(fd, buf, (count > fd->bytesRemain ? fd->bytesRemain : count));
+#else
+	rc = -1;
+#endif
 	/* XXX Chunked davRead EOF. */
 	if (rc == 0)
 	    fd->bytesRemain = 0;
@@ -408,9 +412,13 @@ static ssize_t fdWrite(void * cookie, co
     fdstat_enter(fd, FDSTAT_WRITE);
 /*@-boundsread@*/
     /* HACK: flimsy wiring for davWrite */
-    if (fd->req != NULL)
+    if (fd->req != NULL) {
+#ifdef WITH_NEON
 	rc = davWrite(fd, buf, (count > fd->bytesRemain ? fd->bytesRemain : count));
-    else
+#else
+	return -1;
+#endif
+    } else
 	rc = write(fdno, buf, (count > fd->bytesRemain ? fd->bytesRemain : count));
 /*@=boundsread@*/
     fdstat_exit(fd, FDSTAT_WRITE, rc);
@@ -459,9 +467,13 @@ static int fdClose( /*@only@*/ void * co
     fdstat_enter(fd, FDSTAT_CLOSE);
     /* HACK: flimsy wiring for davClose */
 /*@-branchstate@*/
-    if (fd->req != NULL)
+    if (fd->req != NULL) {
+#ifdef WITH_NEON
 	rc = davClose(fd);
-    else
+#else
+	return -1;
+#endif
+    } else
 	rc = ((fdno >= 0) ? close(fdno) : -2);
 /*@=branchstate@*/
     fdstat_exit(fd, FDSTAT_CLOSE, rc);
@@ -2182,6 +2194,56 @@ exit:
 }
 /*@=nullstate@*/
 
+#ifndef WITH_NEON
+/*@-nullstate@*/        /* FIX: u->{ctrl,data}->url undef after XurlLink. */
+static /*@null@*/ FD_t httpOpen(const char * url, /*@unused@*/ int flags,
+                /*@unused@*/ mode_t mode, /*@out@*/ urlinfo * uret)
+        /*@globals internalState @*/
+        /*@modifies *uret, internalState @*/
+{
+    urlinfo u = NULL;
+    FD_t fd = NULL;
+
+#if 0   /* XXX makeTempFile() heartburn */
+    assert(!(flags & O_RDWR));
+#endif
+    if (urlSplit(url, &u))
+        goto exit;
+
+    if (u->ctrl == NULL)
+        u->ctrl = fdNew("persist ctrl (httpOpen)");
+    if (u->ctrl->nrefs > 2 && u->data == NULL)
+        u->data = fdNew("persist data (httpOpen)");
+
+    if (u->ctrl->url == NULL)
+        fd = fdLink(u->ctrl, "grab ctrl (httpOpen persist ctrl)");
+    else if (u->data->url == NULL)
+        fd = fdLink(u->data, "grab ctrl (httpOpen persist data)");
+    else
+        fd = fdNew("grab ctrl (httpOpen)");
+
+    if (fd) {
+        fdSetIo(fd, ufdio);
+        fd->ftpFileDoneNeeded = 0;
+        fd->rd_timeoutsecs = httpTimeoutSecs;
+        fd->contentLength = fd->bytesRemain = -1;
+        fd->url = urlLink(u, "url (httpOpen)");
+        fd = fdLink(fd, "grab data (httpOpen)");
+        fd->urlType = URL_IS_HTTP;
+    }
+
+exit:
+/*@-boundswrite@*/
+    if (uret)
+        *uret = u;
+/*@=boundswrite@*/
+    /*@-refcounttrans@*/
+    return fd;
+    /*@=refcounttrans@*/
+}
+/*@=nullstate@*/
+#endif
+
 static /*@null@*/ FD_t ufdOpen(const char * url, int flags, mode_t mode)
 	/*@globals h_errno, fileSystem, internalState @*/
 	/*@modifies fileSystem, internalState @*/
@@ -2220,7 +2282,11 @@ fprintf(stderr, "*** ufdOpen(%s,0x%x,0%o
     case URL_IS_HTTPS:
     case URL_IS_HTTP:
     case URL_IS_HKP:
+#ifdef WITH_NEON
 	fd = davOpen(url, flags, mode, &u);
+#else
+	fd = httpOpen(url, flags, mode, &u);
+#endif
 	if (fd == NULL || u == NULL)
 	    break;
 
@@ -2228,7 +2294,11 @@ fprintf(stderr, "*** ufdOpen(%s,0x%x,0%o
 		?  ((flags & O_APPEND) ? "PUT" :
 		   ((flags & O_CREAT) ? "PUT" : "PUT"))
 		: "GET");
+#ifdef WITH_NEON
 	u->openError = davReq(fd, cmd, path);
+#else
+	u->openError = httpReq(fd, cmd, path);
+#endif
 	if (u->openError < 0) {
 	    /* XXX make sure that we can exit through ufdClose */
 	    fd = fdLink(fd, "error ctrl (ufdOpen HTTP)");
Index: rpm-4.4.2/rpmio/rpmrpc.c
===================================================================
--- rpm-4.4.2.orig/rpmio/rpmrpc.c
+++ rpm-4.4.2/rpmio/rpmrpc.c
@@ -93,7 +93,9 @@ int Mkdir (const char * path, mode_t mod
 	/*@notreached@*/ break;
     case URL_IS_HTTPS:
     case URL_IS_HTTP:
+#ifdef WITH_NEON
 	return davMkdir(path, mode);
+#endif
 	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
@@ -151,7 +153,9 @@ int Rmdir (const char * path)
 	/*@notreached@*/ break;
     case URL_IS_HTTPS:
     case URL_IS_HTTP:
+#ifdef WITH_NEON
 	return davRmdir(path);
+#endif
 	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
@@ -182,7 +186,9 @@ int Rename (const char * oldpath, const 
     switch (oldut) {
     case URL_IS_HTTPS:
     case URL_IS_HTTP:
+#ifdef WITH_NEON
 	return davRename(oldpath, newpath);
+#endif
 	/*@notreached@*/ break;
     case URL_IS_FTP:		/* XXX WRONG WRONG WRONG */
     case URL_IS_PATH:
@@ -280,7 +286,9 @@ int Unlink(const char * path) {
 	/*@notreached@*/ break;
     case URL_IS_HTTPS:
     case URL_IS_HTTP:
+#ifdef WITH_NEON
 	return davUnlink(path);
+#endif
 	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
@@ -1282,7 +1290,9 @@ fprintf(stderr, "*** Stat(%s,%p)\n", pat
 	/*@notreached@*/ break;
     case URL_IS_HTTPS:
     case URL_IS_HTTP:
+#ifdef WITH_NEON
 	return davStat(path, st);
+#endif
 	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
@@ -1311,7 +1321,9 @@ fprintf(stderr, "*** Lstat(%s,%p)\n", pa
 	/*@notreached@*/ break;
     case URL_IS_HTTPS:
     case URL_IS_HTTP:
+#ifdef WITH_NEON
 	return davLstat(path, st);
+#endif
 	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
@@ -1489,7 +1501,9 @@ fprintf(stderr, "*** Opendir(%s)\n", pat
 	/*@notreached@*/ break;
     case URL_IS_HTTPS:	
     case URL_IS_HTTP:
+#ifdef WITH_NEON
 	return davOpendir(path);
+#endif
 	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
@@ -1515,8 +1529,10 @@ fprintf(stderr, "*** Readdir(%p)\n", (vo
 	return NULL;
     if (ISAVMAGIC(dir))
 	return avReaddir(dir);
+#ifdef WITH_NEON
     if (ISDAVMAGIC(dir))
 	return davReaddir(dir);
+#endif
     return readdir(dir);
 }
 
@@ -1528,7 +1544,9 @@ fprintf(stderr, "*** Closedir(%p)\n", (v
 	return 0;
     if (ISAVMAGIC(dir))
 	return avClosedir(dir);
+#ifdef WITH_NEON
     if (ISDAVMAGIC(dir))
 	return davClosedir(dir);
+#endif
     return closedir(dir);
 }
Index: rpm-4.4.2/rpmio/url.c
===================================================================
--- rpm-4.4.2.orig/rpmio/url.c
+++ rpm-4.4.2/rpmio/url.c
@@ -147,8 +147,10 @@ URLDBGREFS(0, (stderr, "--> url %p -- %d
 	/*@=usereleased@*/
     }
     if (u->sess != NULL) {
+#ifdef WITH_NEON
 	/* HACK: neon include has prototype. */
 	ne_session_destroy(u->sess);
+#endif
 	u->sess = NULL;
     }
     u->buf = _free(u->buf);
